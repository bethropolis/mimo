/**
 * Mimo → Alya assembly converter.
 *
 * Targets the Alya VM assembler syntax (.alya files).
 *
 * Scope (core subset only):
 *   ✅ Integer literals, arithmetic, boolean logic
 *   ✅ Variables via named @registers
 *   ✅ `show` (integer / boolean values) via `print`
 *   ✅ Variable declarations (`set`, `let`, `const`)
 *   ✅ Assignment operators (+= -= *= /= etc.)
 *   ✅ Unary negation / `not`
 *   ✅ if / else if / else  →  conditional jumps + labels
 *   ✅ while loops          →  loop label + conditional jump
 *   ✅ for…in range()       →  counter + loop label
 *   ✅ break / continue     →  goto
 *   ✅ Function declarations →  call/return + label
 *   ✅ return statement
 *   ✅ Inline if expression  →  conditional move pattern
 *   ⚠️  Strings (literal only, via LoadString + syscall 2)
 *   ❌ Closures, higher-order functions, lambdas
 *   ❌ Objects, arrays, pattern matching
 *   ❌ Imports / stdlib
 *   ❌ try/catch/throw
 *   ❌ Decorators
 *
 * Design decisions:
 *  - Variables use named @registers (Alya allows any @name, not just @r0–@r15).
 *  - Expressions are evaluated into a temporary "virtual accumulator" register
 *    (@__t0, @__t1, …) that the generator allocates and recycles.
 *  - Calling convention:
 *      • Args in @__a0, @__a1, …  (caller sets before `call`)
 *      • Return value in @__ret
 *      • Caller saves its temporaries if needed (currently: simple depth-first
 *        evaluation avoids conflicts within a single expression)
 *  - Labels are generated as   __L<n>   (loops, conditionals, etc.)
 *  - Function labels match function names verbatim.
 *  - `print @reg` is used for integer/boolean output.
 *  - `syscall` (ID 2 in @r0, string address in @r1) is used for string output.
 */

import { BaseConverter } from '../base_converter.js';
import { statementVisitors } from './visitors/statements.js';
import { expressionVisitors } from './visitors/expressions.js';

export class MimoToAlyaConverter extends BaseConverter {
    constructor() {
        super();
        this.indentation = '    ';

        // Counter for unique labels
        this._labelCounter = 0;

        // Temporary register depth (for expression evaluation)
        this._tempDepth = 0;
        this._maxTempDepth = 0;

        // Call-context stack: { breakLabel, continueLabel }
        this._loopStack = [];

        // Deferred function bodies (emit after main code)
        this._functions = []; // [{ name, node }]

        // Track which functions are being compiled (for recursion)
        this._inFunction = false;
        this._currentFunctionParams = null;
        this._currentFunctionLocals = null;
    }

    // =========================================================================
    // Entry point
    // =========================================================================

    convert(ast) {
        this.output = '';

        // Emit a jump to `main` so function bodies defined first don't run.
        this.writeLine('; Generated by Mimo → Alya converter');
        this.writeLine('; Supported subset: integers, arithmetic, variables, if/while/for, functions');
        this.writeLine('');
        this.writeLine('goto __main');
        this.writeLine('');

        // First pass: collect top-level function declarations so forward calls work.
        // (They will be emitted later, after the main body.)
        const body = ast.body || [];
        const mainStmts = [];
        for (const node of body) {
            if (node.type === 'FunctionDeclaration') {
                this._functions.push(node);
            } else {
                mainStmts.push(node);
            }
        }

        // Emit all function bodies first (before main, after the goto)
        for (const fn of this._functions) {
            this._emitFunction(fn);
            this.writeLine('');
        }

        // Main body
        this.writeLine('__main:');
        this.indent();
        let prev = null;
        for (const stmt of mainStmts) {
            this.emitLineGap(stmt, prev);
            this.visitNode(stmt);
            prev = stmt;
        }
        this.writeLine('halt');
        this.dedent();

        return this.output;
    }

    // =========================================================================
    // Label helpers
    // =========================================================================

    /** Allocate a unique label string. */
    newLabel(prefix = 'L') {
        return `__${prefix}${this._labelCounter++}`;
    }

    // =========================================================================
    // Temporary register helpers
    // =========================================================================

    /**
     * Allocate the next temporary register name and return it.
     * Temporaries are @__t0, @__t1, … — they are sequential and
     * the generator never nests two allocations for the same slot
     * within a single expression evaluation path.
     */
    allocTemp() {
        const name = `__t${this._tempDepth}`;
        this._tempDepth++;
        if (this._tempDepth > this._maxTempDepth) {
            this._maxTempDepth = this._tempDepth;
        }
        return name;
    }

    freeTemp() {
        this._tempDepth--;
    }

    // =========================================================================
    // Expression evaluation → register
    //
    // Every expression visitor returns the NAME of the Alya register that
    // holds the result (without the '@' prefix).  The caller is responsible
    // for freeing temporaries it allocated.
    // =========================================================================

    /**
     * Evaluate `node` and return the register name that holds its value.
     * This is the central dispatcher for expression codegen.
     */
    evalExpr(node) {
        switch (node.type) {
            case 'Literal':           return this.evalLiteral(node);
            case 'Identifier':        return this.evalIdentifier(node);
            case 'BinaryExpression':  return this.evalBinary(node);
            case 'UnaryExpression':   return this.evalUnary(node);
            case 'InlineIfExpression': return this.evalInlineIf(node);
            case 'CallExpression':    return this.evalCall(node);
            case 'ModuleAccess':      return this._unsupported(node, 'ModuleAccess');
            case 'PropertyAccess':    return this._unsupported(node, 'PropertyAccess');
            case 'ArrayAccess':       return this._unsupported(node, 'ArrayAccess');
            default:
                return this._unsupported(node, node.type);
        }
    }

    _unsupported(node, label) {
        const tmp = this.allocTemp();
        this.writeLine(`; UNSUPPORTED: ${label} — emitting 0`);
        this.writeLine(`@${tmp} := 0`);
        return tmp;
    }

    // =========================================================================
    // Function emission
    // =========================================================================

    _emitFunction(node) {
        const savedIn = this._inFunction;
        const savedParams = this._currentFunctionParams;
        const savedLocals = this._currentFunctionLocals;

        this._inFunction = true;
        this._currentFunctionParams = new Set((node.params || []).map((p) => p.name));
        this._currentFunctionLocals = new Set();

        const params = node.params || [];
        this.writeLine(`${node.name}:`);
        this.indent();

        // Move arg registers to named param registers
        params.forEach((p, i) => {
            this.writeLine(`@${p.name} := @__a${i}`);
        });

        // Emit body
        let prev = null;
        for (const stmt of node.body || []) {
            this.emitLineGap(stmt, prev);
            this.visitNode(stmt);
            prev = stmt;
        }

        // Implicit return 0
        this.writeLine(`@__ret := 0`);
        this.writeLine(`return`);
        this.dedent();

        this._inFunction = savedIn;
        this._currentFunctionParams = savedParams;
        this._currentFunctionLocals = savedLocals;
    }

    /**
     * Track a local variable name declared inside the current function.
     * Used to determine what to push/pop around recursive calls.
     */
    _trackLocal(name) {
        if (this._currentFunctionLocals) {
            this._currentFunctionLocals.add(name);
        }
    }

    /**
     * Emit push/pop of all live registers (params + locals) around a call.
     * Returns the list of registers pushed (in order) so the caller can pop.
     */
    _emitCallWithSave(calleeName) {
        // Collect everything that must be preserved
        const toSave = [
            ...(this._currentFunctionParams || []),
            ...(this._currentFunctionLocals || []),
        ];

        // Push in order
        for (const reg of toSave) {
            this.writeLine(`push @${reg}`);
        }

        this.writeLine(`call ${calleeName}`);

        // Pop in reverse order
        for (const reg of [...toSave].reverse()) {
            this.writeLine(`@${reg} := pop`);
        }
    }

    // =========================================================================
    // Loop stack helpers
    // =========================================================================

    pushLoop(breakLabel, continueLabel) {
        this._loopStack.push({ breakLabel, continueLabel });
    }

    popLoop() {
        this._loopStack.pop();
    }

    currentLoop() {
        return this._loopStack[this._loopStack.length - 1] || null;
    }

    // =========================================================================
    // Overrides
    // =========================================================================

    onUndefinedVisitor(node) {
        this.writeLine(`; UNSUPPORTED NODE: ${node.type}`);
    }

    /** Alya has no notion of blocks — we just emit flat instructions. */
    visitBlock(statements) {
        (statements || []).forEach((stmt) => this.visitNode(stmt));
    }
}

// Mix in visitors
Object.assign(MimoToAlyaConverter.prototype, statementVisitors, expressionVisitors);
