export const ASTNode = {
  Program: (body, firstToken) => ({ // Add firstToken parameter
    type: "Program",
    body,
    // Ensure these properties come from the token
    line: firstToken.line,
    column: firstToken.column,
    start: firstToken.start,     // Add start
    length: firstToken.length,   // Add length
    file: firstToken.file,
  }),
  VariableDeclaration: (identifier, value, kind, isExported, token) => ({
    type: "VariableDeclaration",
    identifier,
    value,
    kind,
    isExported,
    line: token.line,
    column: token.column,
    start: token.start,   // Add start
    length: token.length, // Add length
    file: token.file,
  }),
  BinaryExpression: (operator, left, right, token) => ({
    type: "BinaryExpression",
    operator,
    left,
    right,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  UnaryExpression: (operator, argument, token) => ({
    type: "UnaryExpression",
    operator,
    argument,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  IfStatement: (condition, consequent, alternate, token) => ({
    type: "IfStatement",
    condition,
    consequent,
    alternate,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  GuardStatement: (condition, alternate, token) => ({
    type: "GuardStatement",
    condition,
    alternate, // The else block that must exit
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  InlineIfExpression: (condition, consequent, alternate, token) => ({
    type: "InlineIfExpression",
    condition,
    consequent, // Single expression here, not a block
    alternate,  // Single expression here, not a block
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  WhileStatement: (condition, body, token) => ({
    type: "WhileStatement",
    condition,
    body,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ForStatement: (variable, iterable, body, token) => ({
    type: "ForStatement",
    variable,
    iterable,
    body,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  RangeLiteral: (start, end, token) => ({
    type: "RangeLiteral",
    start,
    end,
    line: token.line,
    column: token.column,
    length: token.length,
    file: token.file,
  }),
  TryStatement: (tryBlock, catchVar, catchBlock, token) => ({
    type: "TryStatement",
    tryBlock,
    catchVar,
    catchBlock,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ThrowStatement: (argument, token) => ({
    type: "ThrowStatement",
    argument,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  FunctionDeclaration: (name, params, defaults, restParam, body, isExported, token) => ({
    type: "FunctionDeclaration",
    name,
    params, // This should be an array of strings (parameter names)
    defaults,
    restParam, // This should be a string (rest parameter name) or null
    body,
    isExported,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  AnonymousFunction: (params, defaults, restParam, body, token) => ({
    type: "AnonymousFunction",
    params,
    defaults,
    restParam,
    body,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  CallStatement: (callee, args, destination, token) => ({
    type: "CallStatement",
    callee,
    arguments: args,
    destination,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  CallExpression: (callee, args, token) => ({
    type: "CallExpression",
    callee,
    arguments: args,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ShowStatement: (expression, token) => ({
    type: "ShowStatement",
    expression,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ReturnStatement: (argument, token) => ({
    type: "ReturnStatement",
    argument,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  Identifier: (name, token) => ({
    type: "Identifier",
    name,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  Literal: (value, token) => ({
    type: "Literal",
    value,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ArrayLiteral: (elements, token) => ({
    type: "ArrayLiteral",
    elements,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ObjectLiteral: (properties, token) => ({
    type: "ObjectLiteral",
    properties,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ArrayAccess: (object, index, token) => ({
    type: "ArrayAccess",
    object,
    index,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  PropertyAccess: (object, property, token) => ({
    type: "PropertyAccess",
    object,
    property,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  SafePropertyAccess: (object, property, token) => ({
    type: "SafePropertyAccess",
    object,
    property,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  PropertyAssignment: (object, property, value, token) => ({
    type: "PropertyAssignment",
    object,
    property,
    value,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  BracketAssignment: (object, index, value, token) => ({
    type: "BracketAssignment",
    object,
    index,
    value,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  SpreadElement: (argument, token) => ({
    type: "SpreadElement",
    argument,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  DestructuringAssignment: (pattern, expression, token) => ({
    type: "DestructuringAssignment",
    pattern,
    expression,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  BreakStatement: (label, token) => ({
    type: "BreakStatement",
    label,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ContinueStatement: (label, token) => ({
    type: "ContinueStatement",
    label,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  LoopStatement: (body, label, token) => ({
    type: "LoopStatement",
    body,
    label,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  LabeledStatement: (label, statement, token) => ({
    type: "LabeledStatement",
    label,
    statement,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  MatchStatement: (discriminant, cases, token) => ({
    type: "MatchStatement",
    discriminant,
    cases,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  CaseClause: (pattern, guard, consequent, token) => ({
    type: "CaseClause",
    pattern,
    guard,
    consequent,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ArrayPattern: (elements, token) => ({
    type: "ArrayPattern",
    elements,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ObjectPattern: (properties, token) => ({
    type: "ObjectPattern",
    properties,   // An array of Identifier nodes
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ImportStatement: (path, alias, token) => ({
    type: "ImportStatement",
    path,
    alias,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  ModuleAccess: (module, property, token) => ({
    type: "ModuleAccess",
    module,
    property,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
  TemplateLiteral: (parts, token) => ({
    type: "TemplateLiteral",
    parts,
    line: token.line,
    column: token.column,
    start: token.start,
    length: token.length,
    file: token.file,
  }),
};
